"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@contentful";
exports.ids = ["vendor-chunks/@contentful"];
exports.modules = {

/***/ "(ssr)/./node_modules/@contentful/content-source-maps/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@contentful/content-source-maps/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SUPPORTED_WIDGETS: () => (/* binding */ oe),\n/* harmony export */   clone: () => (/* binding */ j),\n/* harmony export */   combine: () => (/* binding */ T),\n/* harmony export */   createSourceMapMetadata: () => (/* binding */ x),\n/* harmony export */   decode: () => (/* binding */ ce),\n/* harmony export */   encode: () => (/* binding */ se),\n/* harmony export */   encodeCPAResponse: () => (/* binding */ ue),\n/* harmony export */   encodeField: () => (/* binding */ C),\n/* harmony export */   encodeGraphQLResponse: () => (/* binding */ ae),\n/* harmony export */   encodeRichTextValue: () => (/* binding */ re),\n/* harmony export */   isBuiltinNamespace: () => (/* binding */ W),\n/* harmony export */   isSupportedWidget: () => (/* binding */ U),\n/* harmony export */   splitEncoding: () => (/* binding */ ie)\n/* harmony export */ });\nvar R = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, b = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, V = new Array(4).fill(String.fromCodePoint(b[0])).join(\"\"), J = \"\\0\";\nfunction _(e) {\n  let t = JSON.stringify(e);\n  return `${V}${Array.from(t).map((o) => {\n    let n = o.charCodeAt(0);\n    if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${o} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((r) => String.fromCodePoint(b[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction D(e) {\n  return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e);\n}\nfunction Q(e) {\n  try {\n    new URL(e, e.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (t) {\n    return !1;\n  }\n  return !0;\n}\nfunction z(e, t, o = \"auto\") {\n  return o === !0 || o === \"auto\" && (D(e) || Q(e)) ? e : `${e}${_(t)}`;\n}\nvar Z = Object.fromEntries(Object.entries(b).map((e) => e.reverse())), k = Object.fromEntries(Object.entries(R).map((e) => e.reverse())), G = `${Object.values(R).map((e) => `\\\\u{${e.toString(16)}}`).join(\"\")}`, O = new RegExp(`[${G}]{4,}`, \"gu\");\nfunction H(e) {\n  let t = e.match(O);\n  if (t) return K(t[0], !0)[0];\n}\nfunction K(e, t = !1) {\n  let o = Array.from(e);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !e.startsWith(V)) return X(o, t);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let n = [];\n  for (let r = o.length * 0.25; r--; ) {\n    let s = o.slice(r * 4, r * 4 + 4).map((i) => Z[i.codePointAt(0)]).join(\"\");\n    n.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (t) {\n    n.shift();\n    let r = n.indexOf(J);\n    return r === -1 && (r = n.length), [JSON.parse(n.slice(0, r).join(\"\"))];\n  }\n  return n.join(\"\").split(J).filter(Boolean).map((r) => JSON.parse(r));\n}\nfunction X(e, t) {\n  var o;\n  let n = [];\n  for (let c = e.length * 0.5; c--; ) {\n    let u = `${k[e[c * 2].codePointAt(0)]}${k[e[c * 2 + 1].codePointAt(0)]}`;\n    n.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [], s = [n.join(\"\")], i = 10;\n  for (; s.length; ) {\n    let c = s.shift();\n    try {\n      if (r.push(JSON.parse(c)), t) return r;\n    } catch (u) {\n      if (!i--) throw u;\n      let f = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!f) throw u;\n      s.unshift(c.substring(0, f), c.substring(f));\n    }\n  }\n  return r;\n}\nfunction Y(e) {\n  var t;\n  return { cleaned: e.replace(O, \"\"), encoded: ((t = e.match(O)) == null ? void 0 : t[0]) || \"\" };\n}\nfunction T(e, t) {\n  return z(e, t);\n}\nfunction se(e) {\n  return _(e);\n}\nfunction ce(e) {\n  return H(e);\n}\nfunction ie(e) {\n  return Y(e);\n}\nvar q = Object.prototype.hasOwnProperty, ee = Object.prototype.toString, te = function(t, o, n) {\n  if (ee.call(o) !== \"[object Function]\")\n    throw new TypeError(\"iterator must be a function\");\n  var r = t.length;\n  if (r === +r)\n    for (var s = 0; s < r; s++)\n      o.call(n, t[s], s, t);\n  else\n    for (var i in t)\n      q.call(t, i) && o.call(n, t[i], i, t);\n}, ne = te, y = a;\nfunction a(e, t, o) {\n  if (arguments.length === 3)\n    return a.set(e, t, o);\n  if (arguments.length === 2)\n    return a.get(e, t);\n  var n = a.bind(a, e);\n  for (var r in a)\n    a.hasOwnProperty(r) && (n[r] = a[r].bind(n, e));\n  return n;\n}\na.get = function(t, o) {\n  for (var n = Array.isArray(o) ? o : a.parse(o), r = 0; r < n.length; ++r) {\n    var s = n[r];\n    if (!(typeof t == \"object\" && s in t))\n      throw new Error(\"Invalid reference token: \" + s);\n    t = t[s];\n  }\n  return t;\n};\na.set = function(t, o, n) {\n  var r = Array.isArray(o) ? o : a.parse(o), s = r[0];\n  if (r.length === 0)\n    throw Error(\"Can not set the root object\");\n  for (var i = 0; i < r.length - 1; ++i) {\n    var c = r[i];\n    typeof c != \"string\" && typeof c != \"number\" && (c = String(c)), !(c === \"__proto__\" || c === \"constructor\" || c === \"prototype\") && (c === \"-\" && Array.isArray(t) && (c = t.length), s = r[i + 1], c in t || (s.match(/^(\\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);\n  }\n  return s === \"-\" && Array.isArray(t) && (s = t.length), t[s] = n, this;\n};\na.remove = function(e, t) {\n  var o = Array.isArray(t) ? t : a.parse(t), n = o[o.length - 1];\n  if (n === void 0)\n    throw new Error('Invalid JSON pointer for remove: \"' + t + '\"');\n  var r = a.get(e, o.slice(0, -1));\n  if (Array.isArray(r)) {\n    var s = +n;\n    if (n === \"\" && isNaN(s))\n      throw new Error('Invalid array index: \"' + n + '\"');\n    Array.prototype.splice.call(r, s, 1);\n  } else\n    delete r[n];\n};\na.dict = function(t, o) {\n  var n = {};\n  return a.walk(t, function(r, s) {\n    n[s] = r;\n  }, o), n;\n};\na.walk = function(t, o, n) {\n  var r = [];\n  n = n || function(s) {\n    var i = Object.prototype.toString.call(s);\n    return i === \"[object Object]\" || i === \"[object Array]\";\n  }, function s(i) {\n    ne(i, function(c, u) {\n      r.push(String(u)), n(c) ? s(c) : o(c, a.compile(r)), r.pop();\n    });\n  }(t);\n};\na.has = function(t, o) {\n  try {\n    a.get(t, o);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n};\na.escape = function(t) {\n  return t.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n};\na.unescape = function(t) {\n  return t.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n};\na.parse = function(t) {\n  if (t === \"\")\n    return [];\n  if (t.charAt(0) !== \"/\")\n    throw new Error(\"Invalid JSON pointer: \" + t);\n  return t.substring(1).split(/\\//).map(a.unescape);\n};\na.compile = function(t) {\n  return t.length === 0 ? \"\" : \"/\" + t.map(a.escape).join(\"/\");\n};\nconst re = ({\n  pointer: e,\n  mappings: t,\n  data: o,\n  hiddenStrings: n\n}) => {\n  const r = t[e];\n  delete t[e];\n  const s = F(o, e);\n  for (const i of s) {\n    t[i] = r;\n    const c = y.get(o, i), u = T(c, n);\n    y.set(o, i, u);\n  }\n}, F = (e, t = \"\") => {\n  const o = [], n = y.get(e, t);\n  if (n.content)\n    for (let r = 0; r < n.content.length; r++)\n      n.content[r].nodeType === \"text\" ? o.push(`${t}/content/${r}/value`) : o.push(...F(e, `${t}/content/${r}`));\n  return o;\n}, x = ({\n  entityId: e,\n  entityType: t,\n  space: o,\n  environment: n,\n  field: r,\n  locale: s,\n  editorInterface: i,\n  fieldType: c,\n  targetOrigin: u,\n  platform: f\n}) => {\n  const d = {\n    origin: \"contentful.com\",\n    href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${n}`}/${t === \"Entry\" ? \"entries\" : \"assets\"}/${e}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n    contentful: {\n      editorInterface: i,\n      fieldType: c\n    }\n  };\n  return f === \"vercel\" && delete d.contentful, d;\n}, W = (e) => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(e), U = (e) => oe.includes(e);\nfunction j(e) {\n  if (typeof structuredClone == \"function\")\n    return structuredClone(e);\n  try {\n    return JSON.parse(JSON.stringify(e));\n  } catch (t) {\n    return console.warn(\"Failed to clone data:\", e, t), e;\n  }\n}\nconst oe = [\n  \"singleLine\",\n  \"tagEditor\",\n  \"listInput\",\n  \"checkbox\",\n  \"richTextEditor\",\n  \"multipleLine\"\n];\nfunction C(e, t, o, n, r, s, i) {\n  const c = i ? t[i] : t;\n  switch (e) {\n    case \"Symbol\": {\n      const u = T(c, o);\n      y.set(n, r, u);\n      break;\n    }\n    case \"Text\": {\n      const u = T(c, o);\n      y.set(n, r, u);\n      break;\n    }\n    case \"RichText\": {\n      re({\n        pointer: \"\",\n        mappings: s,\n        data: c,\n        hiddenStrings: o\n      });\n      break;\n    }\n    case \"Array\": {\n      const u = c.map((f) => typeof f == \"string\" ? T(f, o) : f);\n      y.set(n, r, u);\n      break;\n    }\n  }\n}\nconst ae = (e, t, o) => {\n  if (!e || !e.extensions || !e.extensions.contentSourceMaps)\n    return console.error(\n      \"GraphQL response does not contain Content Source Maps information.\",\n      e\n    ), e;\n  const n = j(e), {\n    spaces: r,\n    environments: s,\n    editorInterfaces: i,\n    fields: c,\n    locales: u,\n    entries: f,\n    assets: p,\n    mappings: g,\n    fieldTypes: v\n  } = n.extensions.contentSourceMaps, h = n;\n  for (const d in g) {\n    const { source: l } = g[d], m = \"entry\" in l ? f[l.entry] : p[l.asset], P = \"entry\" in l ? \"Entry\" : \"Asset\";\n    if (!m)\n      return n;\n    const S = r[m.space], A = s[m.environment], E = m.id, w = c[l.field], I = u[l.locale], N = i[l.editorInterface], L = v[l.fieldType];\n    if (!(W(N.widgetNamespace) && !U(N.widgetId)) && y.has(h, d)) {\n      const M = y.get(h, d);\n      if (M !== null) {\n        const B = x({\n          entityId: E,\n          entityType: P,\n          space: S,\n          environment: A,\n          field: w,\n          locale: I,\n          editorInterface: N,\n          fieldType: L,\n          targetOrigin: t,\n          platform: o\n        });\n        C(L, M, B, h, d, g);\n      }\n    }\n  }\n  return n;\n}, $ = (e, t, o, n, r) => {\n  if (!e.fields)\n    return;\n  const { contentSourceMaps: s } = e.sys;\n  if (!s) {\n    console.error(\"Content source maps data is missing\");\n    return;\n  }\n  const { mappings: i } = s;\n  for (const c in i) {\n    const { source: u } = i[c], f = e.sys.space.sys.id, p = e.sys.environment.sys.id, g = e.sys.id, v = e.sys.type, h = t[u.fieldType], d = o[u.editorInterface];\n    if (W(d.widgetNamespace) && !U(d.widgetId))\n      continue;\n    const l = c.startsWith(\"/\") ? c : `/${c}`;\n    if (y.has(e, l)) {\n      const m = y.get(e, l);\n      if (m === null)\n        return;\n      const S = l.split(\"/\").pop();\n      if (!S) {\n        console.error(\"Field name could not be extracted from the pointer\", l);\n        return;\n      }\n      const A = e.sys.locale;\n      if (A) {\n        const E = x({\n          entityId: g,\n          entityType: v,\n          space: f,\n          environment: p,\n          field: S,\n          locale: A,\n          editorInterface: d,\n          fieldType: h,\n          targetOrigin: n,\n          platform: r\n        });\n        C(h, m, E, e, l, i);\n      } else\n        Object.keys(m).forEach((w) => {\n          const I = x({\n            entityId: g,\n            entityType: v,\n            space: f,\n            environment: p,\n            field: S,\n            locale: w,\n            editorInterface: d,\n            fieldType: h,\n            targetOrigin: n,\n            platform: r\n          });\n          C(\n            h,\n            m,\n            I,\n            e,\n            `${l}/${w}`,\n            i,\n            w\n          );\n        });\n    }\n  }\n}, ue = (e, t, o) => {\n  var r;\n  const n = j(\n    e\n  );\n  if (n.sys && \"items\" in n) {\n    const s = n;\n    if (!((r = s.sys) != null && r.contentSourceMapsLookup))\n      return console.error(\"Content source maps lookup data is missing\"), s;\n    const {\n      contentSourceMapsLookup: { fieldTypes: i, editorInterfaces: c }\n    } = s.sys, { items: u, includes: f } = s;\n    u.forEach(\n      (p) => $(p, i, c, t, o)\n    ), f && f.Entry && f.Entry.forEach(\n      (p) => $(p, i, c, t, o)\n    ), f && f.Asset && f.Asset.forEach(\n      (p) => $(p, i, c, t, o)\n    );\n  } else {\n    const s = n;\n    if (!s.sys.contentSourceMapsLookup)\n      return console.error(\"Content source maps lookup data is missing\"), s;\n    $(\n      s,\n      s.sys.contentSourceMapsLookup.fieldTypes,\n      s.sys.contentSourceMapsLookup.editorInterfaces,\n      t,\n      o\n    );\n  }\n  return n;\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvY29udGVudC1zb3VyY2UtbWFwcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxVQUFVLGlLQUFpSyxRQUFRLHFDQUFxQztBQUN4TjtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUU7QUFDaEI7QUFDQSxvR0FBb0csR0FBRyxlQUFlLEdBQUcsR0FBRyxFQUFFO0FBQzlIO0FBQ0EsR0FBRyxXQUFXO0FBQ2Q7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLHFCQUFxQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxFQUFFLEtBQUs7QUFDdEU7QUFDQSxpSkFBaUosaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLGVBQWUsMkJBQTJCLEVBQUUsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QVcsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AY29udGVudGZ1bC9jb250ZW50LXNvdXJjZS1tYXBzL2Rpc3QvaW5kZXguanM/ZGYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUiA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogODI5MCwgNDogODI5MSwgNTogODI4OCwgNjogNjUyNzksIDc6IDgyODksIDg6IDExOTE1NSwgOTogMTE5MTU2LCBhOiAxMTkxNTcsIGI6IDExOTE1OCwgYzogMTE5MTU5LCBkOiAxMTkxNjAsIGU6IDExOTE2MSwgZjogMTE5MTYyIH0sIGIgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDY1Mjc5IH0sIFYgPSBuZXcgQXJyYXkoNCkuZmlsbChTdHJpbmcuZnJvbUNvZGVQb2ludChiWzBdKSkuam9pbihcIlwiKSwgSiA9IFwiXFwwXCI7XG5mdW5jdGlvbiBfKGUpIHtcbiAgbGV0IHQgPSBKU09OLnN0cmluZ2lmeShlKTtcbiAgcmV0dXJuIGAke1Z9JHtBcnJheS5mcm9tKHQpLm1hcCgobykgPT4ge1xuICAgIGxldCBuID0gby5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChuID4gMjU1KSB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgQVNDSUkgZWRpdCBpbmZvIGNhbiBiZSBlbmNvZGVkLiBFcnJvciBhdHRlbXB0aW5nIHRvIGVuY29kZSAke3R9IG9uIGNoYXJhY3RlciAke299ICgke259KWApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG4udG9TdHJpbmcoNCkucGFkU3RhcnQoNCwgXCIwXCIpKS5tYXAoKHIpID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KGJbcl0pKS5qb2luKFwiXCIpO1xuICB9KS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBEKGUpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4oTnVtYmVyKGUpKSB8fCAvW2Etel0vaS50ZXN0KGUpICYmICEvXFxkKyg/OlstOlxcL11cXGQrKXsyfSg/OlRcXGQrKD86Wy06XFwvXVxcZCspezEsMn0oXFwuXFxkKyk/Wj8pPy8udGVzdChlKSA/ICExIDogISFEYXRlLnBhcnNlKGUpO1xufVxuZnVuY3Rpb24gUShlKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTChlLCBlLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoICh0KSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHooZSwgdCwgbyA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiBvID09PSAhMCB8fCBvID09PSBcImF1dG9cIiAmJiAoRChlKSB8fCBRKGUpKSA/IGUgOiBgJHtlfSR7Xyh0KX1gO1xufVxudmFyIFogPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYikubWFwKChlKSA9PiBlLnJldmVyc2UoKSkpLCBrID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKFIpLm1hcCgoZSkgPT4gZS5yZXZlcnNlKCkpKSwgRyA9IGAke09iamVjdC52YWx1ZXMoUikubWFwKChlKSA9PiBgXFxcXHV7JHtlLnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBPID0gbmV3IFJlZ0V4cChgWyR7R31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBIKGUpIHtcbiAgbGV0IHQgPSBlLm1hdGNoKE8pO1xuICBpZiAodCkgcmV0dXJuIEsodFswXSwgITApWzBdO1xufVxuZnVuY3Rpb24gSyhlLCB0ID0gITEpIHtcbiAgbGV0IG8gPSBBcnJheS5mcm9tKGUpO1xuICBpZiAoby5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgaWYgKG8ubGVuZ3RoICUgNCB8fCAhZS5zdGFydHNXaXRoKFYpKSByZXR1cm4gWChvLCB0KTtcbiAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkVuY29kZWQgZGF0YSBoYXMgaW52YWxpZCBsZW5ndGhcIik7XG4gIGxldCBuID0gW107XG4gIGZvciAobGV0IHIgPSBvLmxlbmd0aCAqIDAuMjU7IHItLTsgKSB7XG4gICAgbGV0IHMgPSBvLnNsaWNlKHIgKiA0LCByICogNCArIDQpLm1hcCgoaSkgPT4gWltpLmNvZGVQb2ludEF0KDApXSkuam9pbihcIlwiKTtcbiAgICBuLnVuc2hpZnQoU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzLCA0KSkpO1xuICB9XG4gIGlmICh0KSB7XG4gICAgbi5zaGlmdCgpO1xuICAgIGxldCByID0gbi5pbmRleE9mKEopO1xuICAgIHJldHVybiByID09PSAtMSAmJiAociA9IG4ubGVuZ3RoKSwgW0pTT04ucGFyc2Uobi5zbGljZSgwLCByKS5qb2luKFwiXCIpKV07XG4gIH1cbiAgcmV0dXJuIG4uam9pbihcIlwiKS5zcGxpdChKKS5maWx0ZXIoQm9vbGVhbikubWFwKChyKSA9PiBKU09OLnBhcnNlKHIpKTtcbn1cbmZ1bmN0aW9uIFgoZSwgdCkge1xuICB2YXIgbztcbiAgbGV0IG4gPSBbXTtcbiAgZm9yIChsZXQgYyA9IGUubGVuZ3RoICogMC41OyBjLS07ICkge1xuICAgIGxldCB1ID0gYCR7a1tlW2MgKiAyXS5jb2RlUG9pbnRBdCgwKV19JHtrW2VbYyAqIDIgKyAxXS5jb2RlUG9pbnRBdCgwKV19YDtcbiAgICBuLnVuc2hpZnQoU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh1LCAxNikpKTtcbiAgfVxuICBsZXQgciA9IFtdLCBzID0gW24uam9pbihcIlwiKV0sIGkgPSAxMDtcbiAgZm9yICg7IHMubGVuZ3RoOyApIHtcbiAgICBsZXQgYyA9IHMuc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHIucHVzaChKU09OLnBhcnNlKGMpKSwgdCkgcmV0dXJuIHI7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaWYgKCFpLS0pIHRocm93IHU7XG4gICAgICBsZXQgZiA9ICsoKG8gPSB1Lm1lc3NhZ2UubWF0Y2goL1xcc3Bvc2l0aW9uXFxzKFxcZCspJC8pKSA9PSBudWxsID8gdm9pZCAwIDogb1sxXSk7XG4gICAgICBpZiAoIWYpIHRocm93IHU7XG4gICAgICBzLnVuc2hpZnQoYy5zdWJzdHJpbmcoMCwgZiksIGMuc3Vic3RyaW5nKGYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBZKGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7IGNsZWFuZWQ6IGUucmVwbGFjZShPLCBcIlwiKSwgZW5jb2RlZDogKCh0ID0gZS5tYXRjaChPKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHRbMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIFQoZSwgdCkge1xuICByZXR1cm4geihlLCB0KTtcbn1cbmZ1bmN0aW9uIHNlKGUpIHtcbiAgcmV0dXJuIF8oZSk7XG59XG5mdW5jdGlvbiBjZShlKSB7XG4gIHJldHVybiBIKGUpO1xufVxuZnVuY3Rpb24gaWUoZSkge1xuICByZXR1cm4gWShlKTtcbn1cbnZhciBxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgZWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCB0ZSA9IGZ1bmN0aW9uKHQsIG8sIG4pIHtcbiAgaWYgKGVlLmNhbGwobykgIT09IFwiW29iamVjdCBGdW5jdGlvbl1cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB2YXIgciA9IHQubGVuZ3RoO1xuICBpZiAociA9PT0gK3IpXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCByOyBzKyspXG4gICAgICBvLmNhbGwobiwgdFtzXSwgcywgdCk7XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpIGluIHQpXG4gICAgICBxLmNhbGwodCwgaSkgJiYgby5jYWxsKG4sIHRbaV0sIGksIHQpO1xufSwgbmUgPSB0ZSwgeSA9IGE7XG5mdW5jdGlvbiBhKGUsIHQsIG8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuIGEuc2V0KGUsIHQsIG8pO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gYS5nZXQoZSwgdCk7XG4gIHZhciBuID0gYS5iaW5kKGEsIGUpO1xuICBmb3IgKHZhciByIGluIGEpXG4gICAgYS5oYXNPd25Qcm9wZXJ0eShyKSAmJiAobltyXSA9IGFbcl0uYmluZChuLCBlKSk7XG4gIHJldHVybiBuO1xufVxuYS5nZXQgPSBmdW5jdGlvbih0LCBvKSB7XG4gIGZvciAodmFyIG4gPSBBcnJheS5pc0FycmF5KG8pID8gbyA6IGEucGFyc2UobyksIHIgPSAwOyByIDwgbi5sZW5ndGg7ICsrcikge1xuICAgIHZhciBzID0gbltyXTtcbiAgICBpZiAoISh0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHMgaW4gdCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlZmVyZW5jZSB0b2tlbjogXCIgKyBzKTtcbiAgICB0ID0gdFtzXTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5hLnNldCA9IGZ1bmN0aW9uKHQsIG8sIG4pIHtcbiAgdmFyIHIgPSBBcnJheS5pc0FycmF5KG8pID8gbyA6IGEucGFyc2UobyksIHMgPSByWzBdO1xuICBpZiAoci5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgRXJyb3IoXCJDYW4gbm90IHNldCB0aGUgcm9vdCBvYmplY3RcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGggLSAxOyArK2kpIHtcbiAgICB2YXIgYyA9IHJbaV07XG4gICAgdHlwZW9mIGMgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYyAhPSBcIm51bWJlclwiICYmIChjID0gU3RyaW5nKGMpKSwgIShjID09PSBcIl9fcHJvdG9fX1wiIHx8IGMgPT09IFwiY29uc3RydWN0b3JcIiB8fCBjID09PSBcInByb3RvdHlwZVwiKSAmJiAoYyA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheSh0KSAmJiAoYyA9IHQubGVuZ3RoKSwgcyA9IHJbaSArIDFdLCBjIGluIHQgfHwgKHMubWF0Y2goL14oXFxkK3wtKSQvKSA/IHRbY10gPSBbXSA6IHRbY10gPSB7fSksIHQgPSB0W2NdKTtcbiAgfVxuICByZXR1cm4gcyA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheSh0KSAmJiAocyA9IHQubGVuZ3RoKSwgdFtzXSA9IG4sIHRoaXM7XG59O1xuYS5yZW1vdmUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBvID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBhLnBhcnNlKHQpLCBuID0gb1tvLmxlbmd0aCAtIDFdO1xuICBpZiAobiA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHJlbW92ZTogXCInICsgdCArICdcIicpO1xuICB2YXIgciA9IGEuZ2V0KGUsIG8uc2xpY2UoMCwgLTEpKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICB2YXIgcyA9ICtuO1xuICAgIGlmIChuID09PSBcIlwiICYmIGlzTmFOKHMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFycmF5IGluZGV4OiBcIicgKyBuICsgJ1wiJyk7XG4gICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHIsIHMsIDEpO1xuICB9IGVsc2VcbiAgICBkZWxldGUgcltuXTtcbn07XG5hLmRpY3QgPSBmdW5jdGlvbih0LCBvKSB7XG4gIHZhciBuID0ge307XG4gIHJldHVybiBhLndhbGsodCwgZnVuY3Rpb24ociwgcykge1xuICAgIG5bc10gPSByO1xuICB9LCBvKSwgbjtcbn07XG5hLndhbGsgPSBmdW5jdGlvbih0LCBvLCBuKSB7XG4gIHZhciByID0gW107XG4gIG4gPSBuIHx8IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgaSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKTtcbiAgICByZXR1cm4gaSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCBpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH0sIGZ1bmN0aW9uIHMoaSkge1xuICAgIG5lKGksIGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgIHIucHVzaChTdHJpbmcodSkpLCBuKGMpID8gcyhjKSA6IG8oYywgYS5jb21waWxlKHIpKSwgci5wb3AoKTtcbiAgICB9KTtcbiAgfSh0KTtcbn07XG5hLmhhcyA9IGZ1bmN0aW9uKHQsIG8pIHtcbiAgdHJ5IHtcbiAgICBhLmdldCh0LCBvKTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59O1xuYS5lc2NhcGUgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0LnRvU3RyaW5nKCkucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufTtcbmEudW5lc2NhcGUgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59O1xuYS5wYXJzZSA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKHQgPT09IFwiXCIpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAodC5jaGFyQXQoMCkgIT09IFwiL1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBwb2ludGVyOiBcIiArIHQpO1xuICByZXR1cm4gdC5zdWJzdHJpbmcoMSkuc3BsaXQoL1xcLy8pLm1hcChhLnVuZXNjYXBlKTtcbn07XG5hLmNvbXBpbGUgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0Lmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBcIi9cIiArIHQubWFwKGEuZXNjYXBlKS5qb2luKFwiL1wiKTtcbn07XG5jb25zdCByZSA9ICh7XG4gIHBvaW50ZXI6IGUsXG4gIG1hcHBpbmdzOiB0LFxuICBkYXRhOiBvLFxuICBoaWRkZW5TdHJpbmdzOiBuXG59KSA9PiB7XG4gIGNvbnN0IHIgPSB0W2VdO1xuICBkZWxldGUgdFtlXTtcbiAgY29uc3QgcyA9IEYobywgZSk7XG4gIGZvciAoY29uc3QgaSBvZiBzKSB7XG4gICAgdFtpXSA9IHI7XG4gICAgY29uc3QgYyA9IHkuZ2V0KG8sIGkpLCB1ID0gVChjLCBuKTtcbiAgICB5LnNldChvLCBpLCB1KTtcbiAgfVxufSwgRiA9IChlLCB0ID0gXCJcIikgPT4ge1xuICBjb25zdCBvID0gW10sIG4gPSB5LmdldChlLCB0KTtcbiAgaWYgKG4uY29udGVudClcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG4uY29udGVudC5sZW5ndGg7IHIrKylcbiAgICAgIG4uY29udGVudFtyXS5ub2RlVHlwZSA9PT0gXCJ0ZXh0XCIgPyBvLnB1c2goYCR7dH0vY29udGVudC8ke3J9L3ZhbHVlYCkgOiBvLnB1c2goLi4uRihlLCBgJHt0fS9jb250ZW50LyR7cn1gKSk7XG4gIHJldHVybiBvO1xufSwgeCA9ICh7XG4gIGVudGl0eUlkOiBlLFxuICBlbnRpdHlUeXBlOiB0LFxuICBzcGFjZTogbyxcbiAgZW52aXJvbm1lbnQ6IG4sXG4gIGZpZWxkOiByLFxuICBsb2NhbGU6IHMsXG4gIGVkaXRvckludGVyZmFjZTogaSxcbiAgZmllbGRUeXBlOiBjLFxuICB0YXJnZXRPcmlnaW46IHUsXG4gIHBsYXRmb3JtOiBmXG59KSA9PiB7XG4gIGNvbnN0IGQgPSB7XG4gICAgb3JpZ2luOiBcImNvbnRlbnRmdWwuY29tXCIsXG4gICAgaHJlZjogYCR7YCR7dSB8fCBcImh0dHBzOi8vYXBwLmNvbnRlbnRmdWwuY29tXCJ9L3NwYWNlcy8ke299L2Vudmlyb25tZW50cy8ke259YH0vJHt0ID09PSBcIkVudHJ5XCIgPyBcImVudHJpZXNcIiA6IFwiYXNzZXRzXCJ9LyR7ZX0vP2ZvY3VzZWRGaWVsZD0ke3J9JmZvY3VzZWRMb2NhbGU9JHtzfSZzb3VyY2U9dmVyY2VsLWNvbnRlbnQtbGlua2AsXG4gICAgY29udGVudGZ1bDoge1xuICAgICAgZWRpdG9ySW50ZXJmYWNlOiBpLFxuICAgICAgZmllbGRUeXBlOiBjXG4gICAgfVxuICB9O1xuICByZXR1cm4gZiA9PT0gXCJ2ZXJjZWxcIiAmJiBkZWxldGUgZC5jb250ZW50ZnVsLCBkO1xufSwgVyA9IChlKSA9PiBbXCJidWlsdGluXCIsIFwic2lkZWJhci1idWlsdGluXCIsIFwiZWRpdG9yLWJ1aWx0aW5cIl0uaW5jbHVkZXMoZSksIFUgPSAoZSkgPT4gb2UuaW5jbHVkZXMoZSk7XG5mdW5jdGlvbiBqKGUpIHtcbiAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICB9IGNhdGNoICh0KSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjbG9uZSBkYXRhOlwiLCBlLCB0KSwgZTtcbiAgfVxufVxuY29uc3Qgb2UgPSBbXG4gIFwic2luZ2xlTGluZVwiLFxuICBcInRhZ0VkaXRvclwiLFxuICBcImxpc3RJbnB1dFwiLFxuICBcImNoZWNrYm94XCIsXG4gIFwicmljaFRleHRFZGl0b3JcIixcbiAgXCJtdWx0aXBsZUxpbmVcIlxuXTtcbmZ1bmN0aW9uIEMoZSwgdCwgbywgbiwgciwgcywgaSkge1xuICBjb25zdCBjID0gaSA/IHRbaV0gOiB0O1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwiU3ltYm9sXCI6IHtcbiAgICAgIGNvbnN0IHUgPSBUKGMsIG8pO1xuICAgICAgeS5zZXQobiwgciwgdSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIlRleHRcIjoge1xuICAgICAgY29uc3QgdSA9IFQoYywgbyk7XG4gICAgICB5LnNldChuLCByLCB1KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiUmljaFRleHRcIjoge1xuICAgICAgcmUoe1xuICAgICAgICBwb2ludGVyOiBcIlwiLFxuICAgICAgICBtYXBwaW5nczogcyxcbiAgICAgICAgZGF0YTogYyxcbiAgICAgICAgaGlkZGVuU3RyaW5nczogb1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIkFycmF5XCI6IHtcbiAgICAgIGNvbnN0IHUgPSBjLm1hcCgoZikgPT4gdHlwZW9mIGYgPT0gXCJzdHJpbmdcIiA/IFQoZiwgbykgOiBmKTtcbiAgICAgIHkuc2V0KG4sIHIsIHUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5jb25zdCBhZSA9IChlLCB0LCBvKSA9PiB7XG4gIGlmICghZSB8fCAhZS5leHRlbnNpb25zIHx8ICFlLmV4dGVuc2lvbnMuY29udGVudFNvdXJjZU1hcHMpXG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIkdyYXBoUUwgcmVzcG9uc2UgZG9lcyBub3QgY29udGFpbiBDb250ZW50IFNvdXJjZSBNYXBzIGluZm9ybWF0aW9uLlwiLFxuICAgICAgZVxuICAgICksIGU7XG4gIGNvbnN0IG4gPSBqKGUpLCB7XG4gICAgc3BhY2VzOiByLFxuICAgIGVudmlyb25tZW50czogcyxcbiAgICBlZGl0b3JJbnRlcmZhY2VzOiBpLFxuICAgIGZpZWxkczogYyxcbiAgICBsb2NhbGVzOiB1LFxuICAgIGVudHJpZXM6IGYsXG4gICAgYXNzZXRzOiBwLFxuICAgIG1hcHBpbmdzOiBnLFxuICAgIGZpZWxkVHlwZXM6IHZcbiAgfSA9IG4uZXh0ZW5zaW9ucy5jb250ZW50U291cmNlTWFwcywgaCA9IG47XG4gIGZvciAoY29uc3QgZCBpbiBnKSB7XG4gICAgY29uc3QgeyBzb3VyY2U6IGwgfSA9IGdbZF0sIG0gPSBcImVudHJ5XCIgaW4gbCA/IGZbbC5lbnRyeV0gOiBwW2wuYXNzZXRdLCBQID0gXCJlbnRyeVwiIGluIGwgPyBcIkVudHJ5XCIgOiBcIkFzc2V0XCI7XG4gICAgaWYgKCFtKVxuICAgICAgcmV0dXJuIG47XG4gICAgY29uc3QgUyA9IHJbbS5zcGFjZV0sIEEgPSBzW20uZW52aXJvbm1lbnRdLCBFID0gbS5pZCwgdyA9IGNbbC5maWVsZF0sIEkgPSB1W2wubG9jYWxlXSwgTiA9IGlbbC5lZGl0b3JJbnRlcmZhY2VdLCBMID0gdltsLmZpZWxkVHlwZV07XG4gICAgaWYgKCEoVyhOLndpZGdldE5hbWVzcGFjZSkgJiYgIVUoTi53aWRnZXRJZCkpICYmIHkuaGFzKGgsIGQpKSB7XG4gICAgICBjb25zdCBNID0geS5nZXQoaCwgZCk7XG4gICAgICBpZiAoTSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBCID0geCh7XG4gICAgICAgICAgZW50aXR5SWQ6IEUsXG4gICAgICAgICAgZW50aXR5VHlwZTogUCxcbiAgICAgICAgICBzcGFjZTogUyxcbiAgICAgICAgICBlbnZpcm9ubWVudDogQSxcbiAgICAgICAgICBmaWVsZDogdyxcbiAgICAgICAgICBsb2NhbGU6IEksXG4gICAgICAgICAgZWRpdG9ySW50ZXJmYWNlOiBOLFxuICAgICAgICAgIGZpZWxkVHlwZTogTCxcbiAgICAgICAgICB0YXJnZXRPcmlnaW46IHQsXG4gICAgICAgICAgcGxhdGZvcm06IG9cbiAgICAgICAgfSk7XG4gICAgICAgIEMoTCwgTSwgQiwgaCwgZCwgZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuO1xufSwgJCA9IChlLCB0LCBvLCBuLCByKSA9PiB7XG4gIGlmICghZS5maWVsZHMpXG4gICAgcmV0dXJuO1xuICBjb25zdCB7IGNvbnRlbnRTb3VyY2VNYXBzOiBzIH0gPSBlLnN5cztcbiAgaWYgKCFzKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvbnRlbnQgc291cmNlIG1hcHMgZGF0YSBpcyBtaXNzaW5nXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IG1hcHBpbmdzOiBpIH0gPSBzO1xuICBmb3IgKGNvbnN0IGMgaW4gaSkge1xuICAgIGNvbnN0IHsgc291cmNlOiB1IH0gPSBpW2NdLCBmID0gZS5zeXMuc3BhY2Uuc3lzLmlkLCBwID0gZS5zeXMuZW52aXJvbm1lbnQuc3lzLmlkLCBnID0gZS5zeXMuaWQsIHYgPSBlLnN5cy50eXBlLCBoID0gdFt1LmZpZWxkVHlwZV0sIGQgPSBvW3UuZWRpdG9ySW50ZXJmYWNlXTtcbiAgICBpZiAoVyhkLndpZGdldE5hbWVzcGFjZSkgJiYgIVUoZC53aWRnZXRJZCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBsID0gYy5zdGFydHNXaXRoKFwiL1wiKSA/IGMgOiBgLyR7Y31gO1xuICAgIGlmICh5LmhhcyhlLCBsKSkge1xuICAgICAgY29uc3QgbSA9IHkuZ2V0KGUsIGwpO1xuICAgICAgaWYgKG0gPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IFMgPSBsLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgIGlmICghUykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmllbGQgbmFtZSBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gdGhlIHBvaW50ZXJcIiwgbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEEgPSBlLnN5cy5sb2NhbGU7XG4gICAgICBpZiAoQSkge1xuICAgICAgICBjb25zdCBFID0geCh7XG4gICAgICAgICAgZW50aXR5SWQ6IGcsXG4gICAgICAgICAgZW50aXR5VHlwZTogdixcbiAgICAgICAgICBzcGFjZTogZixcbiAgICAgICAgICBlbnZpcm9ubWVudDogcCxcbiAgICAgICAgICBmaWVsZDogUyxcbiAgICAgICAgICBsb2NhbGU6IEEsXG4gICAgICAgICAgZWRpdG9ySW50ZXJmYWNlOiBkLFxuICAgICAgICAgIGZpZWxkVHlwZTogaCxcbiAgICAgICAgICB0YXJnZXRPcmlnaW46IG4sXG4gICAgICAgICAgcGxhdGZvcm06IHJcbiAgICAgICAgfSk7XG4gICAgICAgIEMoaCwgbSwgRSwgZSwgbCwgaSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgT2JqZWN0LmtleXMobSkuZm9yRWFjaCgodykgPT4ge1xuICAgICAgICAgIGNvbnN0IEkgPSB4KHtcbiAgICAgICAgICAgIGVudGl0eUlkOiBnLFxuICAgICAgICAgICAgZW50aXR5VHlwZTogdixcbiAgICAgICAgICAgIHNwYWNlOiBmLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHAsXG4gICAgICAgICAgICBmaWVsZDogUyxcbiAgICAgICAgICAgIGxvY2FsZTogdyxcbiAgICAgICAgICAgIGVkaXRvckludGVyZmFjZTogZCxcbiAgICAgICAgICAgIGZpZWxkVHlwZTogaCxcbiAgICAgICAgICAgIHRhcmdldE9yaWdpbjogbixcbiAgICAgICAgICAgIHBsYXRmb3JtOiByXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgQyhcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgSSxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBgJHtsfS8ke3d9YCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICB3XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG59LCB1ZSA9IChlLCB0LCBvKSA9PiB7XG4gIHZhciByO1xuICBjb25zdCBuID0gaihcbiAgICBlXG4gICk7XG4gIGlmIChuLnN5cyAmJiBcIml0ZW1zXCIgaW4gbikge1xuICAgIGNvbnN0IHMgPSBuO1xuICAgIGlmICghKChyID0gcy5zeXMpICE9IG51bGwgJiYgci5jb250ZW50U291cmNlTWFwc0xvb2t1cCkpXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkNvbnRlbnQgc291cmNlIG1hcHMgbG9va3VwIGRhdGEgaXMgbWlzc2luZ1wiKSwgcztcbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U291cmNlTWFwc0xvb2t1cDogeyBmaWVsZFR5cGVzOiBpLCBlZGl0b3JJbnRlcmZhY2VzOiBjIH1cbiAgICB9ID0gcy5zeXMsIHsgaXRlbXM6IHUsIGluY2x1ZGVzOiBmIH0gPSBzO1xuICAgIHUuZm9yRWFjaChcbiAgICAgIChwKSA9PiAkKHAsIGksIGMsIHQsIG8pXG4gICAgKSwgZiAmJiBmLkVudHJ5ICYmIGYuRW50cnkuZm9yRWFjaChcbiAgICAgIChwKSA9PiAkKHAsIGksIGMsIHQsIG8pXG4gICAgKSwgZiAmJiBmLkFzc2V0ICYmIGYuQXNzZXQuZm9yRWFjaChcbiAgICAgIChwKSA9PiAkKHAsIGksIGMsIHQsIG8pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzID0gbjtcbiAgICBpZiAoIXMuc3lzLmNvbnRlbnRTb3VyY2VNYXBzTG9va3VwKVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJDb250ZW50IHNvdXJjZSBtYXBzIGxvb2t1cCBkYXRhIGlzIG1pc3NpbmdcIiksIHM7XG4gICAgJChcbiAgICAgIHMsXG4gICAgICBzLnN5cy5jb250ZW50U291cmNlTWFwc0xvb2t1cC5maWVsZFR5cGVzLFxuICAgICAgcy5zeXMuY29udGVudFNvdXJjZU1hcHNMb29rdXAuZWRpdG9ySW50ZXJmYWNlcyxcbiAgICAgIHQsXG4gICAgICBvXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5leHBvcnQge1xuICBvZSBhcyBTVVBQT1JURURfV0lER0VUUyxcbiAgaiBhcyBjbG9uZSxcbiAgVCBhcyBjb21iaW5lLFxuICB4IGFzIGNyZWF0ZVNvdXJjZU1hcE1ldGFkYXRhLFxuICBjZSBhcyBkZWNvZGUsXG4gIHNlIGFzIGVuY29kZSxcbiAgdWUgYXMgZW5jb2RlQ1BBUmVzcG9uc2UsXG4gIEMgYXMgZW5jb2RlRmllbGQsXG4gIGFlIGFzIGVuY29kZUdyYXBoUUxSZXNwb25zZSxcbiAgcmUgYXMgZW5jb2RlUmljaFRleHRWYWx1ZSxcbiAgVyBhcyBpc0J1aWx0aW5OYW1lc3BhY2UsXG4gIFUgYXMgaXNTdXBwb3J0ZWRXaWRnZXQsXG4gIGllIGFzIHNwbGl0RW5jb2Rpbmdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@contentful/content-source-maps/dist/index.js\n");

/***/ })

};
;